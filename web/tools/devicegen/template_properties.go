package main

import (
	"fmt"
	"sort"
	"strings"
	"text/template"

	devicedef "github.com/jakewright/home-automation/libraries/go/device/def"
	"github.com/jakewright/home-automation/tools/libraries/imports"
)

type propertyTypesData struct {
	PackageName string
	Imports     []*imports.Imp
	Devices     []*deviceData
}

type deviceData struct {
	Name       string
	Properties []*propertyData
}

type propertyData struct {
	NameSnake  string // snake_case
	NameCamel  string // camelCase
	NamePascal string // PascalCase
	Type       string
	GoType     string
	Min        *float64
	Max        *float64
	Options    []*devicedef.Option
}

const propertyTypesText = `// Code generated by devicegen. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end}}
	)
{{- end }}

{{ range $device := .Devices }}
	type {{ $device.Name }}Properties struct {
		{{- range $p := $device.Properties }}
			{{ $p.NamePascal }} *{{ $p.GoType }}
		{{- end }}
	}

	func (p *{{ $device.Name }}Properties) unmarshal(m map[string]interface{}) error {
		for property, value := range m {
			switch property {
				{{- range $p := $device.Properties }}
					case "{{ $p.NameSnake }}":
						{{ if eq $p.Type "int" -}}
							f, ok := value.(float64)
							if !ok {
								return oops.BadRequest("property '{{ $p.NameSnake }}' was unexpected type")
							}

							i := int64(f)
							if f != float64(i) {
								return oops.BadRequest("property '{{ $p.NameSnake }}' should be an integer")
							}

							{{ if $p.Min -}}
								if i < {{ $p.Min }} {
									return oops.BadRequest("property '{{ $p.NameSnake }}' should be ≥ {{ $p.Min }}")
								}
							{{- end }}

							{{ if $p.Max -}}
								if i > {{ $p.Max }} {
									return oops.BadRequest("property '{{ $p.NameSnake }}' should be ≤ {{ $p.Max }}")
								}
							{{- end }}

							p.{{ $p.NamePascal }} = &i

						{{ else if eq $p.Type "bool" -}}
							b, ok := value.(bool)
							if !ok {
								return oops.BadRequest("property '{{ $p.NameSnake }}' was unexpected type",)
							}

							p.{{ $p.NamePascal }} = &b

						{{ else if eq $p.Type "string" -}}
							s, ok := value.(string)
							if !ok {
								return oops.BadRequest("property '{{ $p.NameSnake }}' was unexpected type")
							}

							{{ if $p.Options -}}
								switch s {
									{{- range $op := $p.Options }}
									case "{{ $op.Value }}":
									{{ end -}}
									default:
										return oops.BadRequest("property '{{ $p.NameSnake }}' received invalid option: %s", s)
								}
							{{- end }}

							p.{{ $p.NamePascal }} = &s

						{{ else if eq $p.Type "rgb" -}}
							s, ok := value.(string)
							if !ok {
								return oops.BadRequest("property '{{ $p.NameSnake }}' was unexpected type")
							}

							rgb := &device.RGB{}
							if err := rgb.UnmarshalText([]byte(s)); err != nil {
								return oops.WithMessage(err, "property '{{ $p.NameSnake }}': failed to parse %q as RGB value", s)
							}

							p.{{ $p.NamePascal }} = rgb
						{{ end }}
				{{- end }}

				default:
					return oops.BadRequest("property %q not known", property)
			}
		}

		return nil
	}

	func (p *{{ $device.Name }}Properties) describe() map[string]*def.Property {
		// Dereference all of the pointers. This makes it easier
		// to assert the values are as expected in tests.
		{{- range $p := $device.Properties }}
			var {{ $p.NameCamel }} {{ $p.GoType }}
			if p.{{ $p.NamePascal }} != nil {
				{{ $p.NameCamel }} = *p.{{ $p.NamePascal }}
			}
		{{ end }}

		return map[string]*def.Property{
			{{- range $p := $device.Properties }}
				"{{ $p.NameSnake }}": {
					Value: {{ $p.NameCamel }},
					Type: "{{ $p.Type }}",
					{{- if $p.Min }} 
						Min: ptr.Float64({{ $p.Min }}),
					{{- end -}}
					{{- if $p.Max }}
						Max: ptr.Float64({{ $p.Max }}),
					{{- end -}}
					{{- if $p.Options }}
						Options: []*def.Option{
							{{- range $option := $p.Options }}
								{Value: "{{ $option.Value }}", Name: "{{ $option.Name }}"},
							{{- end }}
						},
					{{- end }}
				},
			{{- end }}
		}
	}
{{- end }}
`

type propertyTypesGenerator struct {
	file file
}

func (g *propertyTypesGenerator) Template() (*template.Template, error) {
	return template.New("types_template").Parse(propertyTypesText)
}

func (g *propertyTypesGenerator) Data(im *imports.Manager) (interface{}, error) {
	im.Add("github.com/jakewright/home-automation/libraries/go/device")
	im.Add("github.com/jakewright/home-automation/libraries/go/device/def")
	im.Add("github.com/jakewright/home-automation/libraries/go/oops")
	im.Add("github.com/jakewright/home-automation/libraries/go/ptr")

	var devices []*deviceData

	// Loop through each device defined in the file
	for deviceName, deviceDesc := range g.file {
		var propertyDatas []*propertyData

		for propertyName, property := range deviceDesc.Properties {
			propertyData, err := parseProperty(propertyName, property)
			if err != nil {
				return nil, err
			}

			propertyDatas = append(propertyDatas, propertyData)
		}

		// Make sure things come out in a consistent order
		sort.Slice(propertyDatas, func(i, j int) bool {
			return propertyDatas[i].NameSnake < propertyDatas[j].NameSnake
		})

		devices = append(devices, &deviceData{
			Name:       deviceName,
			Properties: propertyDatas,
		})
	}

	// Make sure things come out in a consistent order
	sort.Slice(devices, func(i, j int) bool {
		return devices[i].Name < devices[j].Name
	})

	return &propertyTypesData{
		PackageName: pkg,
		Imports:     im.Get(),
		Devices:     devices,
	}, nil
}

func (g *propertyTypesGenerator) Filename() string {
	return "properties.go"
}

func parseProperty(name string, p property) (*propertyData, error) {
	if !isSnake(name) {
		return nil, fmt.Errorf("property name %q should be snake_case", name)
	}

	switch p.Type {
	case "int":
		return parseIntProperty(name, p)
	case "bool":
		return parseBoolProperty(name, p)
	case "string":
		return parseStringProperty(name, p)
	case "rgb":
		return parseRGBProperty(name, p)
	}

	return nil, fmt.Errorf("invalid property type %q", p.Type)
}

func parseIntProperty(name string, p property) (*propertyData, error) {
	d := &propertyData{
		NameSnake:  name,
		NameCamel:  snakeToCamelCase(name),
		NamePascal: camelToPascalCase(name),
		Type:       "int",
		GoType:     "int64",
	}

	if p.Min != nil {
		d.Min = p.Min
	}

	if p.Max != nil {
		d.Max = p.Max
	}

	if len(p.Options) > 0 {
		return nil, fmt.Errorf("int property %q can't have options", name)
	}

	return d, nil
}

func parseBoolProperty(name string, p property) (*propertyData, error) {
	d := &propertyData{
		NameSnake:  name,
		NameCamel:  snakeToCamelCase(name),
		NamePascal: camelToPascalCase(name),
		Type:       "bool",
		GoType:     "bool",
	}

	if p.Min != nil {
		return nil, fmt.Errorf("bool property %q can't have a min value", name)
	}

	if p.Max != nil {
		return nil, fmt.Errorf("bool property %q can't have a max value", name)
	}

	if len(p.Options) > 0 {
		return nil, fmt.Errorf("bool property %q can't have options", name)
	}

	return d, nil
}

func parseStringProperty(name string, p property) (*propertyData, error) {
	d := &propertyData{
		NameSnake:  name,
		NameCamel:  snakeToCamelCase(name),
		NamePascal: camelToPascalCase(name),
		Type:       "string",
		GoType:     "string",
	}

	if p.Min != nil {
		return nil, fmt.Errorf("bool property %q can't have a min value", name)
	}

	if p.Max != nil {
		return nil, fmt.Errorf("bool property %q can't have a max value", name)
	}

	if len(p.Options) > 0 {
		d.Options = p.Options
	}

	return d, nil
}

func parseRGBProperty(name string, p property) (*propertyData, error) {
	d := &propertyData{
		NameSnake:  name,
		NameCamel:  snakeToCamelCase(name),
		NamePascal: camelToPascalCase(name),
		Type:       "rgb",
		GoType:     "device.RGB",
	}

	if p.Min != nil {
		return nil, fmt.Errorf("rgb property %q can't have a min value", name)
	}

	if p.Max != nil {
		return nil, fmt.Errorf("rgb property %q can't have a max value", name)
	}

	if len(p.Options) > 0 {
		return nil, fmt.Errorf("rgb property %q can't have options", name)
	}

	return d, nil
}

func isSnake(s string) bool {
	return s == strings.ToLower(s)
}

func snakeToCamelCase(s string) string {
	var camel string
	var upper bool

	for _, c := range s {
		switch {
		case c == '_':
			upper = true
		case upper:
			camel += strings.ToUpper(string(c))
			upper = false
		default:
			camel += string(c)
		}
	}

	return camel
}

func camelToPascalCase(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}
